# coding: utf-8

from __future__ import absolute_import

import copy
import hashlib
import hmac
import multiprocessing
from collections import OrderedDict
from datetime import datetime
from enum import Enum

import boto3
import requests
from cachetools import TTLCache
import urllib
from urllib.parse import urlparse


class MarketplaceRegion(Enum):
    US = ('https://sellingpartnerapi-na.amazon.com', 'us-east-1', "ATVPDKIKX0DER")
    CA = ('https://sellingpartnerapi-na.amazon.com', 'us-east-1', "A2EUQ1WTGCTBG2")
    MX = ('https://sellingpartnerapi-na.amazon.com', 'us-east-1', "A1AM78C64UM0Y8")
    BR = ('https://sellingpartnerapi-na.amazon.com', 'us-east-1', "A2Q3Y263D00KWC")

    JP = ('https://sellingpartnerapi-fe.amazon.com', 'us-west-2', "A1VC38T7YXB528")
    AU = ('https://sellingpartnerapi-fe.amazon.com', 'us-west-2', "A39IBJ37TRP1C6")
    SG = ('https://sellingpartnerapi-fe.amazon.com', 'us-west-2', "A19VAU5U5O7RUS")

    UK = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A1F83G8C2ARO7P")
    GB = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A1F83G8C2ARO7P")
    NL = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A1805IZSGTT6HS")
    FR = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A13V1IB3VIYZZH")
    IT = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "APJ6JRA9NG5V4")
    ES = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A1RKKUPIHCS9HS")
    SE = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A2NODRKZP88ZB9")
    TR = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A33AVAJ2PDY3EV")
    DE = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A1PA6795UKMFR9")
    AE = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A2VIGQ35RCS4UG")
    IN = ('https://sellingpartnerapi-eu.amazon.com', 'eu-west-1', "A21TJRUUN4KGV")

    def __init__(self, host, aws_region, marketplace):
        self.host = host
        self.aws_region = aws_region
        self.marketplace = marketplace


class Configuration(object):

    _default = None
    _role_cache = TTLCache(maxsize=10, ttl=3800)
    _access_token_cache = TTLCache(maxsize=1000, ttl=3800)

    def __init__(self, **kwargs):
        """Constructor"""
        if self._default:
            for key in self._default.__dict__.keys():
                self.__dict__[key] = copy.copy(self._default.__dict__[key])
            return

        self.role_arn = kwargs.get('role_arn')
        self.refresh_token = kwargs.get('refresh_token')
        self.aws_access_key = kwargs.get('aws_access_key')
        self.aws_secret_key = kwargs.get('aws_secret_key')
        self.client_id = kwargs.get('client_id')
        self.client_secret = kwargs.get('client_secret')
        self._client = boto3.client('sts', aws_access_key_id=self.aws_access_key, aws_secret_access_key=self.aws_secret_key)
        self.marketplace = MarketplaceRegion[kwargs.get('region', 'US')].marketplace
        self.host = MarketplaceRegion[kwargs.get('region', 'US')].host
        # Temp file folder for downloading files
        self.temp_folder_path = None

        self.aws_region = MarketplaceRegion[kwargs.get('region', 'US')].aws_region

        # SSL/TLS verification
        # Set this to false to skip verifying SSL certificate when calling API
        # from https server.
        self.verify_ssl = True
        # Set this to customize the certificate file to verify the peer.
        self.ssl_ca_cert = None
        # client certificate file
        self.cert_file = None
        # client key file
        self.key_file = None
        # Set this to True/False to enable/disable SSL hostname verification.
        self.assert_hostname = None

        # urllib3 connection pool's maximum number of connections saved
        # per pool. urllib3 uses 1 connection as default value, but this is
        # not the best value when you are making a lot of possibly parallel
        # requests to the same host, which is often the case here.
        # cpu_count * 5 is used as default value to increase performance.
        self.connection_pool_maxsize = multiprocessing.cpu_count() * 5

        # Proxy URL
        self.proxy = None
        # Safe chars for path_param
        self.safe_chars_for_path_param = ''

        # Disable client side validation
        self.client_side_validation = True

    def __get_access_token(self):
        if self.refresh_token not in self._access_token_cache:
            data = {
                'grant_type': 'refresh_token',
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'refresh_token': self.refresh_token,
            }
            headers = {
                'User-Agent': 'python-sp-api',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8',
            }
            response = requests.post('https://api.amazon.com/auth/o2/token', data=data, headers=headers, timeout=180)
            if response.status_code != 200:
                raise RuntimeError("get access_token failed:{}".format(response.text))
            access_token = response.json()['access_token']
            self._access_token_cache[self.refresh_token] = access_token

        parsed_headers = {
            'host': self.host[8:],
            'user-agent': 'python-sp-api',
            'x-amz-access-token': self._access_token_cache[self.refresh_token],
            'x-amz-date': datetime.utcnow().strftime('%Y%m%dT%H%M%SZ'),
            'content-type': 'application/json'}
        return parsed_headers

    def get_auth(self, r):
        if 'role' not in self._role_cache:
            role = self._client.assume_role(RoleArn=self.role_arn, RoleSessionName='guid').get('Credentials')
            self._role_cache['role'] = role
        role = self._role_cache['role']
        access_header = self.__get_access_token()
        signed_header = self.sign(r, role.get('AccessKeyId'), role.get('SecretAccessKey'), self.aws_region, role.get('SessionToken'))
        access_header.update(signed_header)
        return access_header

    @staticmethod
    def sign_msg(key, msg):
        return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

    def sign(self, r, aws_access_key_id, aws_secret_access_key, region, aws_session_token):
        # Create a date for headers and the credential string
        t = datetime.utcnow()
        amz_date = t.strftime('%Y%m%dT%H%M%SZ')
        datestamp = t.strftime('%Y%m%d')
        # Parse request to get URL parts
        p = urlparse(r.url)

        host = p.hostname
        uri = urllib.parse.quote(p.path)

        if len(p.query) > 0:
            qs = dict(map(lambda i: i.split('='), p.query.split('&')))
        else:
            qs = dict()

        canonical_querystring = "&".join(map(lambda x: '='.join(x), sorted(qs.items())))
        headers_to_sign = {'host': host, 'x-amz-date': amz_date}
        if aws_session_token is not None:
            headers_to_sign['x-amz-security-token'] = aws_session_token

        ordered_headers = OrderedDict(sorted(headers_to_sign.items(), key=lambda t: t[0]))
        canonical_headers = ''.join(map(lambda h: ":".join(h) + '\n', ordered_headers.items()))
        signed_headers = ';'.join(ordered_headers.keys())

        if r.method == 'GET':
            payload_hash = hashlib.sha256(''.encode('utf-8')).hexdigest()
        else:
            if r.body:
                payload_hash = hashlib.sha256(r.body.encode('utf-8')).hexdigest()
            else:
                payload_hash = hashlib.sha256(''.encode('utf-8')).hexdigest()

        canonical_request = '\n'.join([r.method, uri, canonical_querystring, canonical_headers, signed_headers, payload_hash])

        credential_scope = '/'.join([datestamp, region, "execute-api", 'aws4_request'])
        string_to_sign = '\n'.join(['AWS4-HMAC-SHA256', amz_date, credential_scope, hashlib.sha256(canonical_request.encode('utf-8')).hexdigest()])

        k_date = self.sign_msg(('AWS4' + aws_secret_access_key).encode('utf-8'), datestamp)
        k_region = self.sign_msg(k_date, region)
        k_service = self.sign_msg(k_region, "execute-api")
        k_signing = self.sign_msg(k_service, 'aws4_request')
        signature = hmac.new(k_signing, string_to_sign.encode('utf-8'), hashlib.sha256).hexdigest()

        authorization_header = "AWS4-HMAC-SHA256 Credential={}/{}, SignedHeaders={}, Signature={}".format(
            aws_access_key_id, credential_scope, signed_headers, signature)

        return {
            'host': host,
            'x-amz-date': amz_date,
            'Authorization': authorization_header,
            'x-amz-security-token': aws_session_token
        }
